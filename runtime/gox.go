package gox

import (
	"bytes"
	"fmt"
	"html"
	"io"
)

// Node is the basic interface that all elements, components, and text implement.
type Node interface {
	Render(w io.Writer) error
}

// Props is a map to hold component attributes.
type Props map[string]any

// ElementNode represents a standard HTML element like <div> or <p>.
type ElementNode struct {
	TagName  string
	Props    Props
	Children []Node
}

// TextNode represents a simple string of text.
type TextNode string

// ComponentNode represents a user-defined component.
type ComponentNode struct {
	Component func(Props, ...Node) Node
	Props     Props
	Children  []Node
}

func (t TextNode) Render(w io.Writer) error {
	_, err := w.Write([]byte(html.EscapeString(string(t))))
	return err
}

func (c ComponentNode) Render(w io.Writer) error {
	// Execute the component function to get its resulting node tree, then render that.
	node := c.Component(c.Props, c.Children...)
	if node == nil {
		return nil // If the component returns nil, we do nothing.
	}
	return node.Render(w)
}

// --- Creator Functions (These will be generated by the compiler) ---

// El creates a standard HTML element.
func El(tagName string, props Props, children ...Node) Node {
	return ElementNode{TagName: tagName, Props: props, Children: children}
}

// Text creates a text node. It's helpful for wrapping Go expressions.
func Text(content any) Node {
	return TextNode(fmt.Sprintf("%v", content))
}

// Component creates a component node.
func Component(fn func(Props, ...Node) Node, props Props, children ...Node) Node {
	return ComponentNode{Component: fn, Props: props, Children: children}
}

// --- Public API ---

// Render takes a root node and renders it to a string.
func Render(root Node) (string, error) {
	var buf bytes.Buffer
	if err := root.Render(&buf); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// Implementation for ElementNode.Render
func (e ElementNode) Render(w io.Writer) error {
	// Write opening tag
	if _, err := fmt.Fprintf(w, "<%s", e.TagName); err != nil {
		return err
	}

	// Write attributes
	for key, val := range e.Props {
		if _, err := fmt.Fprintf(w, ` %s="%s"`, key, html.EscapeString(fmt.Sprintf("%v", val))); err != nil {
			return err
		}
	}

	// Write ending tag
	if _, err := fmt.Fprint(w, ">"); err != nil {
		return err
	}

	// Render children
	for _, child := range e.Children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	// Write closing tag
	if _, err := fmt.Fprintf(w, "</%s>", e.TagName); err != nil {
		return err
	}

	return nil
}
